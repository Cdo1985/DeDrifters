<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Degen Drifters: Pro Racer</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #0a0a0a; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        
        #ui { 
            position: absolute; 
            top: 20px; 
            left: 20px; 
            color: white; 
            pointer-events: none;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            z-index: 10;
            width: 350px;
        }

        .hud-panel {
            background: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            border-left: 5px solid #e74c3c;
            margin-bottom: 10px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.6);
        }

        h1 { margin: 0 0 5px 0; font-size: 24px; letter-spacing: 2px; text-transform: uppercase; font-style: italic; color: #e74c3c; }
        p { margin: 0; font-size: 14px; opacity: 0.8; font-weight: bold; }
        
        #score-container {
            font-size: 32px;
            font-weight: 900;
            color: #f1c40f;
            margin-top: 10px;
            font-style: italic;
            display: flex;
            align-items: baseline;
            gap: 10px;
        }
        #score-label { font-size: 14px; color: white; opacity: 0.6; text-transform: uppercase; }

        .fuel-container {
            margin-top: 15px;
            width: 100%;
            height: 12px;
            background: rgba(255,255,255,0.1);
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.2);
        }
        #fuel-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #e74c3c, #f1c40f, #2ecc71);
            transition: width 0.3s ease;
        }

        #speedometer {
            position: absolute;
            bottom: 30px;
            right: 30px;
            text-align: right;
            color: white;
            pointer-events: none;
        }
        #speed-value { font-size: 64px; font-weight: 900; font-style: italic; line-height: 1; color: #e74c3c; }
        
        #msg-overlay {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #f1c40f;
            font-size: 48px;
            font-weight: 900;
            font-style: italic;
            text-transform: uppercase;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s, transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-shadow: 0 0 30px rgba(241, 196, 15, 0.8);
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 50px;
            border-radius: 30px;
            text-align: center;
            display: none;
            z-index: 100;
            border: 3px solid #e74c3c;
            color: white;
            box-shadow: 0 0 100px rgba(231, 76, 60, 0.3);
        }
        #game-over button {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 20px 40px;
            font-size: 24px;
            border-radius: 15px;
            cursor: pointer;
            font-weight: 900;
            margin-top: 25px;
            text-transform: uppercase;
        }

        canvas { display: block; }
    </style>
</head>
<body>
    <div id="ui">
        <div class="hud-panel">
            <h1>DRIFT KING</h1>
            <p>WIDER LANES | STIFF STEERING</p>
            <div id="score-container">
                <span id="score-label">Points</span>
                <span id="score-val">0</span>
            </div>
            <div class="fuel-container">
                <div id="fuel-bar"></div>
            </div>
        </div>
    </div>

    <div id="msg-overlay">NEAR MISS!</div>

    <div id="game-over">
        <h2 style="font-size: 60px; color: #e74c3c; margin: 0;">WRECKED</h2>
        <p id="final-score" style="font-size: 24px; color: #f1c40f; margin: 20px 0;"></p>
        <button onclick="restart()">RESTART RACE</button>
    </div>

    <div id="speedometer">
        <div id="speed-value">0</div>
        <div style="font-size: 14px; opacity: 0.7; letter-spacing: 3px;">DRIFT VELOCITY</div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

// --- Configuration ---
const CONFIG = {
    friction: 0.99,       // INCREASED GRIP (less slide)
    driftFriction: 0.98,  // INCREASED GRIP (less slide)
    accel: 0.62,          // Slightly boosted for snappiness
    steerSpeed: 0.12,     // STIFFER, FASTER TURN
    maxSkidPoints: 800,
    gridSize: 200,
    tokenCount: 8,
    poleCount: 12,
    spawnRange: 4500,
    trackWidth: 1000,     // WIDER TRACK
    nearMissDist: 200,    // Adjusted for wider lanes
    driftThreshold: 2.8   // Higher threshold for less sliding
};

// --- Game State ---
let camera, keys, particles, skidmarks, tokens, poles, carPieces, fuel, score, isGameOver;
let trackPoints = [];

function resetState() {
    camera = { x: 0, y: 0, zoom: 0.8 };
    keys = { w: false, s: false, a: false, d: false, space: false };
    particles = [];
    skidmarks = [];
    tokens = [];
    poles = [];
    carPieces = [];
    fuel = 100;
    score = 0;
    isGameOver = false;

    car.x = 0; car.y = 0; car.vx = 0; car.vy = 0; car.angle = 0;
    
    initTrack();
    initWorld();
    document.getElementById('game-over').style.display = 'none';
}

const car = {
    x: 0, y: 0, angle: 0, vx: 0, vy: 0,
    width: 110, height: 52,
    color: '#e74c3c',
    steerAngle: 0
};

function initTrack() {
    trackPoints = [];
    let curX = 0, curY = 0, curAngle = 0;
    for (let i = 0; i < 60; i++) {
        trackPoints.push({ x: curX, y: curY });
        curAngle += (Math.random() - 0.5) * 1.2; // Slightly straighter track sections
        curX += Math.cos(curAngle) * 1000;
        curY += Math.sin(curAngle) * 1000;
    }
}

function initWorld() {
    for (let i = 0; i < CONFIG.tokenCount; i++) spawnToken();
    for (let i = 0; i < CONFIG.poleCount; i++) spawnPole();
}

function spawnToken() {
    const tp = trackPoints[Math.floor(Math.random() * trackPoints.length)];
    tokens.push({
        x: tp.x + (Math.random() - 0.5) * CONFIG.trackWidth * 0.8,
        y: tp.y + (Math.random() - 0.5) * CONFIG.trackWidth * 0.8,
        size: 25, pulse: Math.random() * 10
    });
}

function spawnPole() {
    let x, y, onTrack = true;
    while(onTrack) {
        x = car.x + (Math.random() - 0.5) * CONFIG.spawnRange;
        y = car.y + (Math.random() - 0.5) * CONFIG.spawnRange;
        onTrack = isPointOnTrack(x, y, CONFIG.trackWidth * 1.3);
    }
    poles.push({ x, y, radius: 55, missed: false });
}

function isPointOnTrack(px, py, width) {
    for (let i = 0; i < trackPoints.length - 1; i++) {
        const p1 = trackPoints[i], p2 = trackPoints[i+1];
        const dist = distToSegment(px, py, p1.x, p1.y, p2.x, p2.y);
        if (dist < width/2) return true;
    }
    return false;
}

function distToSegment(px, py, x1, y1, x2, y2) {
    const l2 = (x1-x2)**2 + (y1-y2)**2;
    if (l2 === 0) return Math.hypot(px-x1, py-y1);
    let t = ((px-x1)*(x2-x1) + (py-y1)*(y2-y1)) / l2;
    t = Math.max(0, Math.min(1, t));
    return Math.hypot(px - (x1 + t*(x2-x1)), py - (y1 + t*(y2-y1)));
}

// --- Input ---
window.addEventListener("keydown", (e) => {
    if (isGameOver) return;
    const key = e.code.toLowerCase();
    if (key === "keyw" || key === "arrowup") keys.w = true;
    if (key === "keys" || key === "arrowdown") keys.s = true;
    if (key === "keya" || key === "arrowleft") keys.a = true;
    if (key === "keyd" || key === "arrowright") keys.d = true;
    if (key === "space") keys.space = true;
});

window.addEventListener("keyup", (e) => {
    const key = e.code.toLowerCase();
    if (key === "keyw" || key === "arrowup") keys.w = false;
    if (key === "keys" || key === "arrowdown") keys.s = false;
    if (key === "keya" || key === "arrowleft") keys.a = false;
    if (key === "keyd" || key === "arrowright") keys.d = false;
    if (key === "space") keys.space = false;
});

function showMsg(text) {
    const el = document.getElementById('msg-overlay');
    el.textContent = text;
    el.style.opacity = 1;
    el.style.transform = 'translate(-50%, -50%) scale(1.5)';
    setTimeout(() => {
        el.style.opacity = 0;
        el.style.transform = 'translate(-50%, -50%) scale(1)';
    }, 800);
}

function destroyCar() {
    if (isGameOver) return;
    isGameOver = true;
    document.getElementById('game-over').style.display = 'block';
    document.getElementById('final-score').textContent = "TOTAL SCORE: " + Math.floor(score);

    for (let i = 0; i < 20; i++) {
        carPieces.push({
            x: car.x, y: car.y,
            vx: car.vx + (Math.random() - 0.5) * 15,
            vy: car.vy + (Math.random() - 0.5) * 15,
            angle: Math.random() * Math.PI * 2,
            va: (Math.random() - 0.5) * 0.8,
            w: Math.random() * 30 + 10, h: Math.random() * 15 + 5,
            color: Math.random() > 0.4 ? car.color : '#333'
        });
    }
    createSmoke(car.x, car.y, 60, 8);
}

function restart() { resetState(); }
function lerp(s, e, t) { return s * (1 - t) + e * t; }

function createSmoke(x, y, amount, drift = 1) {
    for (let i = 0; i < amount; i++) {
        particles.push({
            x, y,
            vx: (Math.random() - 0.5) * 3 * drift,
            vy: (Math.random() - 0.5) * 3 * drift,
            size: Math.random() * 15 + 15,
            life: 1.0, decay: 0.005 + Math.random() * 0.01
        });
    }
}

function addSkidMark(x, y, angle) {
    skidmarks.push({ x, y, angle, life: 1.0 });
    if (skidmarks.length > CONFIG.maxSkidPoints) skidmarks.shift();
}

// --- Update ---
function update() {
    if (isGameOver) {
        carPieces.forEach(p => {
            p.x += p.vx; p.y += p.vy; p.angle += p.va;
            p.vx *= 0.985; p.vy *= 0.985;
        });
        return;
    }

    const speed = Math.sqrt(car.vx * car.vx + car.vy * car.vy);
    const isDrifting = keys.space;

    fuel -= 0.015;
    if (fuel <= 0) { fuel = 0; keys.w = false; }

    // FASTER INTERPOLATION FOR STIFF TURN
    const targetSteer = (keys.d - keys.a) * 0.5;
    car.steerAngle = lerp(car.steerAngle, targetSteer, 0.3); // Increased from 0.15
    
    if (speed > 0.5) {
        const dir = (car.vx * Math.cos(car.angle) + car.vy * Math.sin(car.angle) < 0) ? -1 : 1;
        car.angle += car.steerAngle * CONFIG.steerSpeed * (speed / (speed + 8)) * dir;
    }

    if (keys.w) { car.vx += Math.cos(car.angle) * CONFIG.accel; car.vy += Math.sin(car.angle) * CONFIG.accel; }
    if (keys.s) { car.vx -= Math.cos(car.angle) * 0.4; car.vy -= Math.sin(car.angle) * 0.4; }

    const fric = isDrifting ? CONFIG.driftFriction : CONFIG.friction;
    car.vx *= fric; car.vy *= fric;
    car.x += car.vx; car.y += car.vy;

    const latVel = Math.abs(car.vx * -Math.sin(car.angle) + car.vy * Math.cos(car.angle));

    // Scoring logic
    if (latVel > CONFIG.driftThreshold) {
        score += latVel * 0.5;
    }

    // Near Miss check
    poles.forEach(p => {
        const d = Math.hypot(car.x - p.x, car.y - p.y);
        if (d < 95) destroyCar();
        else if (d < CONFIG.nearMissDist && speed > 5 && !p.missed) {
            score += 500;
            p.missed = true;
            showMsg("NEAR MISS +500!");
            setTimeout(() => p.missed = false, 2000);
        }
    });

    tokens.forEach((t, i) => {
        const d = Math.hypot(car.x - t.x, car.y - t.y);
        if (d < 65) {
            if (latVel > CONFIG.driftThreshold || isDrifting) {
                fuel = Math.min(100, fuel + 35);
                score += 1000;
                tokens.splice(i, 1); spawnToken();
                showMsg("DRIFT REFUEL +1000");
            }
        }
    });

    // Object Recycling
    [...tokens, ...poles].forEach(obj => {
        const d = Math.hypot(car.x - obj.x, car.y - obj.y);
        if (d > CONFIG.spawnRange * 0.95) {
            if (obj.radius) { // It's a pole
                let nx, ny, onTrack = true;
                while(onTrack) {
                    nx = car.x + (Math.random() - 0.5) * CONFIG.spawnRange;
                    ny = car.y + (Math.random() - 0.5) * CONFIG.spawnRange;
                    onTrack = isPointOnTrack(nx, ny, CONFIG.trackWidth * 1.3);
                }
                obj.x = nx; obj.y = ny;
            } else { // It's a token
                const tp = trackPoints[Math.floor(Math.random() * trackPoints.length)];
                obj.x = tp.x + (Math.random() - 0.5) * CONFIG.trackWidth;
                obj.y = tp.y + (Math.random() - 0.5) * CONFIG.trackWidth;
            }
        }
    });

    if (speed > 2) {
        const rx = car.x - Math.cos(car.angle) * 45;
        const ry = car.y - Math.sin(car.angle) * 45;
        const px = -Math.sin(car.angle) * 22;
        const py = Math.cos(car.angle) * 22;

        if (isDrifting || latVel > 2.5) {
            createSmoke(rx + px, ry + py, 4, latVel * 0.5);
            createSmoke(rx - px, ry - py, 4, latVel * 0.5);
            addSkidMark(rx + px, ry + py, car.angle);
            addSkidMark(rx - px, ry - py, car.angle);
        }
    }

    camera.x = lerp(camera.x, car.x + car.vx * 15, 0.08);
    camera.y = lerp(camera.y, car.y + car.vy * 15, 0.08);
    camera.zoom = lerp(camera.zoom, 0.8 - Math.min(speed / 130, 0.25), 0.05);

    particles.forEach((p, i) => {
        p.x += p.vx; p.y += p.vy; p.size += 0.5; p.life -= p.decay;
        if (p.life <= 0) particles.splice(i, 1);
    });
    skidmarks.forEach((s, i) => {
        s.life -= 0.0025;
        if (s.life <= 0) skidmarks.splice(i, 1);
    });

    document.getElementById('speed-value').textContent = Math.floor(latVel * 12);
    document.getElementById('fuel-bar').style.width = fuel + '%';
    document.getElementById('score-val').textContent = Math.floor(score);
}

// --- Draw ---
function draw() {
    ctx.fillStyle = '#0f0f0f';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.save();
    ctx.translate(canvas.width/2, canvas.height/2);
    ctx.scale(camera.zoom, camera.zoom);
    ctx.translate(-camera.x, -camera.y);

    // Draw Track
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    // Track Bed
    ctx.strokeStyle = '#222';
    ctx.lineWidth = CONFIG.trackWidth;
    ctx.beginPath();
    trackPoints.forEach((p, i) => i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
    ctx.stroke();

    // Track Markings
    ctx.strokeStyle = '#2a2a2a';
    ctx.lineWidth = CONFIG.trackWidth - 40;
    ctx.stroke();
    
    ctx.setLineDash([50, 70]);
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.lineWidth = 15;
    ctx.stroke();
    ctx.setLineDash([]);

    // Skidmarks
    skidmarks.forEach(s => {
        ctx.fillStyle = `rgba(0,0,0,${s.life * 0.4})`;
        ctx.save(); ctx.translate(s.x, s.y); ctx.rotate(s.angle);
        ctx.fillRect(-10, -7, 20, 14); ctx.restore();
    });

    // Pillars
    poles.forEach(p => {
        const r = p.radius;
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.beginPath(); ctx.arc(p.x + 15, p.y + 15, r, 0, Math.PI*2); ctx.fill();
        
        const grad = ctx.createLinearGradient(p.x - r, p.y, p.x + r, p.y);
        grad.addColorStop(0, '#333'); grad.addColorStop(0.5, '#fff'); grad.addColorStop(1, '#333');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(p.x, p.y, r, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#000'; ctx.lineWidth = 6; ctx.stroke();
        
        ctx.fillStyle = '#111';
        ctx.beginPath(); ctx.arc(p.x, p.y, r * 0.7, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#e74c3c'; ctx.lineWidth = 4; ctx.stroke();
    });

    // Tokens
    tokens.forEach(t => {
        t.pulse += 0.15;
        const s = 30 + Math.sin(t.pulse) * 8;
        ctx.fillStyle = 'rgba(241, 196, 15, 0.3)';
        ctx.beginPath(); ctx.arc(t.x, t.y, s*1.8, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#f1c40f';
        ctx.beginPath(); ctx.arc(t.x, t.y, s*0.8, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 4; ctx.stroke();
    });

    // Smoke
    particles.forEach(p => {
        ctx.fillStyle = `rgba(200, 200, 200, ${p.life * 0.45})`;
        ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
    });

    if (!isGameOver) drawCar();
    else {
        carPieces.forEach(p => {
            ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(p.angle);
            ctx.fillStyle = p.color; ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
            ctx.restore();
        });
    }

    ctx.restore();
}

function drawCar() {
    ctx.save(); ctx.translate(car.x, car.y); ctx.rotate(car.angle);
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.roundRect(-car.width/2+10, -car.height/2+10, car.width, car.height, 12);
    ctx.fill();

    const bodyGrad = ctx.createLinearGradient(0, -car.height/2, 0, car.height/2);
    bodyGrad.addColorStop(0, '#e74c3c'); bodyGrad.addColorStop(1, '#9b2c2c');
    ctx.fillStyle = bodyGrad;
    ctx.beginPath(); ctx.roundRect(-car.width/2, -car.height/2, car.width, car.height, 14); ctx.fill();
    
    ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.lineWidth = 3; ctx.stroke();

    ctx.fillStyle = '#1a252f';
    ctx.roundRect(5, -car.height/2 + 8, 45, car.height - 16, 6); ctx.fill();

    ctx.fillStyle = '#fff'; ctx.shadowBlur = 15; ctx.shadowColor = '#fff';
    ctx.fillRect(car.width/2-6, -car.height/2+8, 7, 13);
    ctx.fillRect(car.width/2-6, car.height/2-21, 7, 13);
    ctx.shadowBlur = 0;

    ctx.restore();
}

function loop() { update(); draw(); requestAnimationFrame(loop); }
window.addEventListener("resize", () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });
canvas.width = window.innerWidth; canvas.height = window.innerHeight;
resetState();
loop();
</script>
</body>
</html>
